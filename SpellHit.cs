using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public class spellHit
{
    //private Entity _target;
    //public Entity target { get { return _target; } }
    public Entity target;

    /// <summary>
    /// ids given to objects when syncing cast to clients, so they know what object is being referenced when it collides/explodes/hits/etc
    /// </summary>
    public List<int> serialization_ids = new List<int>();

    //TODO- cause projectiles and all non-SyncObject instances of moving/destroyable animations to write themself to this on Awake/Creation
    //this will then sync to the client during SyncUnsentCasts...Client will then also call OnAnimationHit... and during Awake/Creation the objects will retrieve their ID rather than assign
    //clear entries of the client dictionary whose CastStarted is older than some threshold...
    //when client does SyncUnsentOnAnimationHits it will try to retrieve the object from that dictionary and do OnAnimationHit

    //now go back and deterministically read the serialization_ids during instantiation after Write on client
    //then add self to the dictionary <int, ISerialiableAnimationObject> and wait...
    //then on client, read from that dictionary again during SyncUnsentOnAnimationHit to get what is being referenced

    //now just clear the old entries in dictionary (possibly based on castFinished)
    //and figure out a way to use OnTriggerStay (possibly supply a function to Projectile instead of overloading OnAnimationHit)

    public Vector3 vTarget;
    public Vector3 origin;
    public SyncObject sTarget;

    public Entity caster;

    /// <summary>
    ///  initialized on spellHit creation
    /// </summary>
    public int casterID;
    public Spell spell; //what started it

    public int power;
    public float power_nonDamage; //power that isn't effected by normal bonuses like "+4% increased damage"
    public float leechHealthPercent = 0;
    public int damageReflected;
    public int cost;

    /// <summary>
    /// how much this ability fills the charge meter
    /// </summary>
    public float chargeGained;
    /// <summary>
    /// how much charge to remove when spell is finished
    /// </summary>
    private float _chargeUsed;
    
    /// <summary>
    /// (not allowed to set directly)
    /// final amount of charge used during FinishCast after taking into account current/max charge of caster.
    /// This value is used for effects that mod power based on charge used
    /// </summary>
    public float chargeUsed { get => _chargeUsed; }
    
    /// <summary>
    /// maximum amount of charge to use for this ability (before clamping to current charge). differs from this.chargeUsed due to amount of charge available, which is the final calculated amount
    /// </summary>
    public float maxChargeUsed = 7;
    /// <summary>
    /// how much charge is required to make the spell cast
    /// </summary>
    public float minChargeUsed = 0;

    public bool instantCast => castTime <= 0; //will return true if <= 0
    public float castTime;
    public DateTime castStarted;
    public float moveSpeed;

    public float critChance;

    /// <summary>
    /// 1.0F based (1 is perfect hit chance)
    /// </summary>
    public float hitChance = 1;
    public float critBonus = 2;

    public float dodgeChance;
    public float resistChance;
    public float evadeChance;
    public float parryChance;
    public float blockChance;

    public float duration;
    public float interval;
    public float cooldown;
    /// <summary>
    /// not to be confused with radius
    /// </summary>
    public float range;

    /// <summary>
    /// used for AoEs
    /// </summary>
    public float radius;

    /// <summary>
    /// when the spellHit is used as a status effect, this is how many charges it has left. Not used for anything except tracking when to remove, and maybe if you want to make a spell that procs when you have charges for consuming or else
    /// </summary>
    public int stacks = 1;
    /// <summary>
    /// how many stacks fit on a target as a status effect
    /// </summary>
    public int maxStacks = 5;
    public int summonsCount = 1;
    public int numStrikes = 1;

    /// <summary>
    /// used to interact with and upgrade amount generated by "miners"/ "gold farms" etc
    /// </summary>
    public int generateCurrencyAmount;

    public bool inturruptedByMovement = true;

    public List<int> spellTypes = new List<int>(); //this actually kind of sucks. We insert the spellType into the spellHit rather than being able to tell from the base spell, because the two are not necessarily the same after talents.

    public bool isHeal => spellTypes.Contains(spellType.healing); //used on some effects that only modify the values of healing spells
    /// <summary>
    /// WARNING- won't return true during _PreHit phase if there isn't target yet, as with a projectile
    /// </summary>
    public bool isDamage => target != null && power > 0 && !isHeal;
    public bool isProjectile => moveSpeed > 0 && duration > 0;

    /// <summary>
    /// true if it is a buff, false if it is a debuff
    /// </summary>
    public bool buffDebuff;

    private spellHit()
    { //any creation of spellhit outside this class should be rather explicit

    }

    /// <summary>
    /// creates an empty spellHit, which is otherwise VERY discouraged due to the complex nature and hierarchy of spellHit calculations. This is the only acceptable implementation- creating it for a spellBaseValue constructor.
    /// Instead use the constructor that takes a previous spellHit, ensuring it originated from a spellBaseValue.
    /// </summary>
    public static spellHit GetEmptyFor_SpellConstructor(Spell spell)
    {
        spellHit returns = new spellHit();
        returns.spell = spell;
        return returns;
    }

    /// <summary>
    /// set this.chargeUsed based on this.maxChargeUsed. This explicit function is to prevent setting chargeUsed directly (which may be particular to class/object) when you mean to set maxChargeUsed
    /// </summary>
    public void CalcChargeUsed() {
        if (caster.ContainsSyncField(SyncCharge.charge))
            _chargeUsed = Math.Max(0, Math.Min(maxChargeUsed, caster.Get<float>(SyncCharge.charge))); //value must be between 0 and current charge
        else
            _chargeUsed = 0;
    }

    /// <summary>
    /// this function is meant to keep the chargeUsed field of spellHit private
    /// </summary>
    public void RemoveChargeFromCaster()
    {
        if(_chargeUsed > 0)
        { //if has the component
            caster.Subtraction(SyncCharge.charge, ref _chargeUsed);
        }
    } //end RemoveChargeFromCaster

    /*
    //required to fill all target and origin fields to imply explicitity and discretion
    public spellHit(Entity caster, Vector3 origin, Vector3 vTarget, Entity target, Spell spell)
    {
        origin = this.origin; this.vTarget = vTarget; this.caster = caster; this.spell = spell; if(caster != null) casterID = caster.id;
        SetCalculatedTarget(target); //set private _target field and calculate defensive mods
    }
    */

    //only entry point to creating new spellHits...ensuring you either call GetEmptyFor_SpellConstructor from a spell, or are trying to make a copy of one that already did call it
    //this ensures that defensive calculations are only called once on the final target (preventing errors from skipping across multiple targets and calculating defensively on each of them...), because defensive calculations are only called from spellHit.SetCalculatedTarget
    //if SetCalculatedTarget is called when the spellHit already has a target, an exception will be thrown
    public spellHit (spellHit old, Entity caster, Entity target, Vector3 origin, Vector3 vTarget)
    {
        this.vTarget = vTarget;
        this.origin = origin;
        this.caster = caster;
        if(caster != null)
            this.casterID = caster.id; //can't use old because old might be spellBaseValues
        this.spell = old.spell;
        this.power = old.power;
        this.power_nonDamage = old.power_nonDamage;
        this.cost = old.cost;
        this.castTime = old.castTime;
        this.castStarted = old.castStarted;
        this.critChance = old.critChance;
        this.hitChance = old.hitChance;
        this.critBonus = old.critBonus;
        this.dodgeChance = old.dodgeChance;
        this.resistChance = old.resistChance;
        this.evadeChance = old.evadeChance;
        this.parryChance = old.parryChance;
        this.blockChance = old.blockChance;
        this.duration = old.duration;
        this.interval = old.interval;
        this.cooldown = old.cooldown;
        this.range = old.range;
        this.radius = old.radius;
        this.stacks = old.stacks;
        this.maxStacks = old.maxStacks;
        this.inturruptedByMovement = old.inturruptedByMovement;
        this.spellTypes = new List<int>(old.spellTypes);
        this.moveSpeed = old.moveSpeed;
        this.summonsCount = old.summonsCount;
        this.numStrikes = old.numStrikes;
        this.leechHealthPercent = old.leechHealthPercent;
        this.generateCurrencyAmount = old.generateCurrencyAmount;
        this.damageReflected = old.damageReflected;
        this.buffDebuff = old.buffDebuff; //theoretically we should just be modifying this after we create this instance anyway, so not needed
        this.chargeGained = old.chargeGained;
        this.maxChargeUsed = old.maxChargeUsed;
        this._chargeUsed = old._chargeUsed;
        this.target = target;
    } //end function NewHitFrom


    bool calculatedTarget;
    /// <summary>
    /// set the target of this spellHit and consequently recalculate this spellHit based on that Entity.
    /// Can only be done once- throw an error if target is already set, because you really should actually deep copy this spellhit with a new target. This explicitly ensures Defensive mods are always calculated appropriately
    /// </summary>
    public void SetCalculatedTarget(Entity target)
    {
        if (!calculatedTarget)
        { //if haven't run these calculations yet...
            calculatedTarget = true;
          //set value and also recalculate properties based on entity's defenses
            if (target != null && !target.destroyed)
            {
                this.target = target;
                if (target != caster || isHeal)
                { //don't perform defensive damage calculations if the caster is targeting themself
                    
                    //offensive _PostHit calculations
                    //from spell
                    spell.CalcCastFlatOffensive_PostHit(this); //populate with base info on range, cast time, damage, etc
                    spell.CalcCastPerOffensive_PostHit(this); //populate with further info on range, cast time, etc

                    //bonuses from caster on everything, importantly cast time and range
                    caster.CalcCastFlatOffensive_PostHit(this);
                    caster.CalcCastPerOffensive_PostHit(this);

                    TeamSpellModifier.instance.CalcCastFlatOffensive_PostHit(this); //perform team bonus calculations on caster
                    TeamSpellModifier.instance.CalcCastPerOffensive_PostHit(this); //perform team bonus calculations on caster
                    //end offensive _PostHit calculations


                    //perform defensive calculations here (when target is being set) to sanitize the code from calculating defensive bonuses twice, like on an AoE
                    target.CalcCastFlatDefensive(this);
                    SyncArmor.TryCalc(this, target); //do armor damage reduction if exists
                    target.CalcCastPerDefensive(this);

                    TeamSpellModifier.instance.CalcCastFlatDefensive(this); //perform team bonus calculations on this.target
                    TeamSpellModifier.instance.CalcCastPerDefensive(this); //perform team bonus calculations on this.target

                }
            }
        } else
        {
            Logger.LogError("tried to inproperly set the target of a spellHit that was already calculated on a target");
        }
    }

} // end class spellHit
